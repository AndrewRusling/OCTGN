**Quick-Jump: [Global](#globalClass) | [Player](#playerClass) | [Group](#groupClass) | [Table](#tableClass) | [Pile](#pileClass) | [Card](#cardClass)**

----------

<a name="globalClass"/>
# GLOBAL CLASS
 FUNCTION | DESCRIPTION | VERSION ADDED   
----------|-------------|---------------
 [askCard()](#askcard) | Shows a dialog box so that the user can choose a card type and quantity |
 [askChoice()](#askchoice) | Shows a dialog box with multiple buttons that the user can choose from | 3.1.35 27/05/2013
 [askInteger()](#askinteger) | Creates a dialog box to input a number |
 [askMarker()](#askmarker) | Shows a dialog box so that the user can choose a marker type and quantity |
 [confirm()](#confirm) | Creates a yes/no dialog box |
 [gameVersion()](#gameversion) | Returns the game definition's current version |
 [getGlobalVariable()](#getglobalvariable) | Returns the value of a game-defined global variable |
 [getSetting()](#getsetting) | Returns a saved game setting | 3.1.56 30/07/2013
 [mute()](#mute) | Mute's OCTGN's automatic chat log notifications |
 [notify()](#notify) | Sends a notification message to all players |
 [openUrl()](#openurl) | Opens the URL in your default browser |
 [getPlayers()](#getplayers) | Returns a list of all players in the game | 3.1.110 22/11/2013
 [playSound()](#playsound) | Plays a pre-defined sound file |
 [remoteCall()](#remotecall) | Invokes a function remotely for a specific player | 3.1.87 08/09/2013
 [rnd()](#rnd) | Generates a random number between two integers |
 [setGlobalVariable()](#setglobalvariable) | Sets the value of a game-defined global variable |
 [setSetting()](#setsetting) | Saves a game setting | 3.1.56 30/07/2013
 [turnNumber()](#turnnumber) | Returns the internal turn count |
 [version()](#version) | Returns OCTGN's current version |
 [webRead()](#webread) | Reads the contents of a URL and the HTTP status code |
 [whisper()](#whisper) | Sends a notification message to the local player |
 [update()](#update) | Forces the Python engine to wait until OCTGN's queued networking processes are finished. | 3.1.92 11/09/2013

<a name="mute" />
## mute()

Stops OCTGN from logging its own messages to the chat log. This only applies to the context of the executed function, and does not persist between Python functions.

This function is useful if you want to use your own chat log notifications for functions such as shuffling, adding markers to cards, increasing counters, or moving cards.

<a name="notify"/>
## notify(message)

| Argument | Type    |Description |
|----------|---------|------------|
| message | string | a customized message to send to the chat log of all players. |

Sends a customized message to the chat log of all players.  You can use Python's `str.format()` method to include variables in the string.

If you pass a [Player object](#playerClass) as a variable, OCTGN will replace it with the player's nickname.  If you pass a [Card object](#cardClass), OCTGN will replace it with the card's name, and you can 'Hover' over the name to display the card's image.

```python
notify("{} plays {} from his hand.".format(me, card))
>>> "Joe plays Ace of Spades from his hand."
```
<a name="whisper" />

**Important:** It's been discovered that one some user's PC, OCTGN will crash if you start a notify with a linebreak '\n'. If you want to start your message with a linebreak, add a whitespace in front.

## whisper(message)

| Argument | Type    |Description |
|----------|---------|------------|
| message | string | a customized message to send to the local player's chat log. |

Sends a customized message to the chat log of the local player only.  You can use Python's `str.format()` method to include variables in the string.

If you pass a [Player object](#playerClass) as a variable, OCTGN will replace it with the player's nickname.  If you pass a [Card object](#cardClass), OCTGN will replace it with the card's name, and you can 'Hover' over the name to display the card's image.

```python
whisper("You can't play {}, {}.".format(card, me))
>>> "You can't play Blue Bunny, Dave."
```

**NOTE**: Since `whisper()` doesn't send through the server network, it sometimes appears in the chat log before notify() messages will, even if whisper() is processed first.

## rnd(min, max)

| Argument | Type    |Description |
|----------|---------|------------|
| min | integer | The lowest value that the random number can be |
| max | integer | The highest value that the random number can be |

Returns a random **INTEGER** value between *min* and *max*.

This method is generally better than Python's built-in functions because it is distributed. Other players can check that you don't cheat while choosing the number.

```python
num = rnd(3, 6)
print num
>>> 5
```

Due to `rnd()`'s distributed nature, it had become a popular work-around to several of OCTGN's bugs and issues, such as [#412](https://github.com/kellyelton/OCTGN/issues/412) and [#110](https://github.com/kellyelton/OCTGN/issues/110). It can force a delay at a specific point of a script's execution, to allow OCTGN to 'catch up' with the script execution.  However, the [update()](#update) function has been recently written to more effectively address this issue.

<a name="webread" />
## webRead(url, timeout = 0)

| Argument | Type    |Description |
|----------|---------|------------|
| url | string | The URL of a web page |
| timeout | integer | **(OPTIONAL)** The length of time (in milliseconds) to wait before timing out.

Reads the contents of a web page

Returns a **tuple** (contents, code) where **STRING** *contents* is the contents of the web page, and **INT** *code* is the HTTP code of that page (currently supports 200, 403, 404, 500).

```python
contents, code = webRead('http://www.mysite.com/test.php', 5000)
print contents
>>> 'Welcome to my webpage!'
print code
>>> 200
```

NOTE: The intended purpose of this method is to allow python to read simple text web pages hosted online, to allow more dynamic scripting without having to force game definition updates.  There may be many other uses as well.

<a name="openurl" />
## openUrl(url)

| Argument | Type    |Description |
|----------|---------|------------|
| url | string | The URL of a web page |

Opens the user's default web browser to the URL given.  It will always ask for the user's permission first, to allow for URL verification.  Please be responsible when using this method.

```python
openUrl('http://www.octgn.net')
```

<a name="turnnumber" />
## turnNumber()

Read-only: Returns the current turn number as an **INTEGER** (from the internal turn counter).

```python
turn = turnNumber()
print turn
>>> 7
```

<a name="confirm" />
## confirm(message)

| Argument | Type    |Description |
|----------|---------|------------|
| message | string | a customized message to display in the dialog box. |

Displays a dialog window with the message, and YES/NO buttons as inputs. 

Returns **True** if the user chooses 'YES', **False** if the user chooses 'NO', and **None** if they close the window.

```python
choice = confirm("Do you want to play {}?".format(card.name))
print choice
>>> False
```

<a name="askinteger" />
## askInteger(message, defaultValue)

| Argument | Type    |Description |
|----------|---------|------------|
| message | string | a customized message to display in the dialog box. |
| defaultValue | integer | the default number to display in the input box. |

Displays a dialog box with the message, and an input box to enter in a **POSITIVE INTEGER** value.

Returns the inputted **INTEGER**, or **None** if the user closes the window instead.

```python
count = askInteger("Draw how many cards?", 10)
if count == None: return
print count
>>> 10
```

<a name="askmarker" />
## askMarker()

Displays a dialog box with all markers defined in the game, so that the user can choose a marker and quantity.

Returns a **tuple** (guid, quantity), where **STRING** *guid* is the GUID of the chosen marker, and **INTEGER** *quantity* is the chosen quantity.  (None, 0) will be returned if the user doesn't choose a marker (closes the window).

```python
marker, qty = askMarker()
if qty == 0: return
card.markers[marker] += qty
print marker
>>> '19663776-58c4-431e-850b-70f3f05118dc'
print qty
>>> 4
```

<a name="askchoice" />
## askChoice(message, buttonList, colorList, customButtons = [])

| Argument | Type    |Description |
|----------|---------|------------|
| message | string | a customized message to display in the dialog box. |
| buttonList | list | A list of **STRING** values specifying the labels of each choice button. |
| colorList | list | a list of **STRING** values specifying the color of each button's background.  The color values MUST be in the #HEX color format. |
| customButtons | list | **(OPTIONAL)** A list of **STRING** values specifying the labels for custom buttons at the bottom of the window. |

Displays a multiple-choice dialog box with a list of buttons that the user can choose from. Optional *customButton* confirmation-style buttons can also be defined which returns a special case.

Returns **0** if the window is closed, or an **INTEGER** value (starting with 1) corresponding to the chosen button's placement in the window.  If customButtons are defined, then clicking one of those will return a negative number, (starting with -1) ordered similarly to buttonList.

(NOTE: that the returning integer will always be 1 greater than the index of that label in the original choice List)

```python
choiceList = ['Heart', 'Diamond', 'Spade', 'Club']
colorsList = ['#FF0000', '#FF0000', '#000000', '#000000'] 
choice = askChoice("Pick a suit:", choiceList, colorsList, customButtons = ["Nah I'm good"])
print choice
>>> 2
```
NOTE: The colors list must be the exact same length as the choice list, as they correspond to the same indexes.  If the lengths are different, then the colors will not appear.

<a name="askcard" />
## askCard(properties, operator = "and")

| Argument | Type    |Description |
|----------|---------|------------|
| properties | dictionary | A dictionary of property:value pairs that filter the viewable cards in the window. |
| operator | string | **(OPTIONAL)** Only accepts "and" or "or", as operators for the filtered list. |

_This function is case insensitive_

Displays a dialog so that the user can choose a card type and quantity.  Cards are pulled from the card database and filtered based on property matches listed in the dictionary.

Returns a **tuple** (guid, quantity), where **STRING** *guid* is the GUID of the chosen card, and **INTEGER** *quantity* is the chosen quantity.  (None, 0) will be returned if the user doesn't choose a card (closes the window).

The *properties* parameter should follow the proper Python syntax for dictionaries, and all objects in the dictionary should be **STRING**s.  You may pass a pre-defined dictionary as a variable.  Having multiple keys in the dictionary allows filtering of multiple properties.

The optional *operator* defines how the properties are filtered, and only accepts "or" and "and". It will default to "and" if no operator is given.

**Example:** Shows only cards where `Color` == `Red` and `Rank` == `Queen`
```python
card, quantity = askCard({"Color":"Red","Rank":"Queen"}, "and")
if quantity == 0: return
table.create(card, x, y, quantity)
```

<a name="getplayers" />
## getPlayers()

Returns a list of all [Player object](#playerClass)s currently connected to the game.  Note that this list is UNSORTED, that is, the local player (You) is always first in this list.

This method is different from the `players` constant because it is *dynamic*, and will change if a player leaves or joins the game.  `players` will always return the original list of players when the game started.


<a name="version" />
## version()

Returns the **STRING** version of OCTGN that the user is using.

```python
version = version()
print version
>>> "3.1.82.510"
```

<a name="gameversion" />
## gameVersion()

Returns the **STRING** version of the game definition that the user is using.

```python
version = gameVersion()
print version
>>> "1.0.2.0"
```

<a name="getglobalvariable" />
## getGlobalVariable(name)

(see [this link](definition.xml#wiki-globalvariables) for more information on OCTGN's GlobalVariable system.)

| Argument | Type    |Description |
|----------|---------|------------|
| name | string | The name of a game-defined Global Variable |

Returns the **STRING** stored data that is defined in the Game Definition as **.

NOTE: *name* is stored in OCTGN as a **STRING**, and will probably need to be converted back into its original type.  You can do this with Python's `eval(var)` method.

```python
cards = eval(getGlobalVariable("cardList"))
print cards
>>> ["Queen", "Jack", "10"]
```

<a name="setglobalvariable" />
## setGlobalVariable(name, value)

(see [this link](definition.xml#wiki-globalvariables) for more information on OCTGN's GlobalVariable system.)

| Argument | Type    |Description |
|----------|---------|------------|
| name | string | The name of a game-defined Global Variable |
| value | string | The value to store into the Global Variable |

NOTE: The variable MUST be converted to a **STRING** before it is stored via `setGlobalVariable()`.  You can do this with Python's `str(var)` method.

```python
cards = ["Queen", "Jack", "10"]
setGlobalVariable("cardList", str(cards))
```

<a name="setsetting" />
## setSetting(name, value)

| Argument | Type    |Description |
|----------|---------|------------|
| name | string | The name of a game setting |
| value | any type | A variable object to store into the named setting |

Stores a variable as a local game setting, identifiable by its *name*. All standard python object types are supported (string, int, list, etc...) EXCEPT DICTIONARIES (see note below).  Game settings are stored permanently and are retained when a game is closed, but are only readable by the local player.

examples of use:

```python
setSetting("MaleGender", True) // Stores a boolean True/False, in this case to store the player's gender.
```
```python
setSetting("PlayerAge", 25)  // Stores an integer value
```

NOTE!!! Python dictionaries currently break the settings file.  If you want to store a dictionary object as a setting, you MUST convert it to a .NET dictionary first! When you use getSetting, it will return as a Python Dictionary.

example of conversion:
```
   pythonDict = {"key": 3, "anotherkey": 73}
   netDict = Dictionary[str,int](pyDict)
```


<a name="getsetting" />
## getSetting(name, defaultValue)

| Argument | Type    |Description |
|----------|---------|------------|
| name | string | The name of a game setting |
| defaultValue | any type | A default value to return, if the setting doesn't exist yet |

Retrieves a previously-stored Game Setting with the specified name.  A *defaultValue* must be included, in the case where that Game Setting has not yet been created or stored, and should match the object type that would be expected.

Warning: Keep in mind [bug #968](https://github.com/kellyelton/OCTGN/issues/968)

examples of use:

`` age = getSetting("PlayerAge", 20) // Will return the stored variable, else default to 20.``

<a name="playsound" />
## playSound(name)


(see [this link](definition.xml#wiki-sounds) for more information on OCTGN's Sound system.)

| Argument | Type    |Description |
|----------|---------|------------|
| name | string | The name of a game-defined Sound |

Plays a sound with name as defined in the game definition.

```python
playSound('beep')
```

<a name="remotecall" />
## remoteCall(player, function, arguments)

Argument | Type | Description
---------|------|------------
player | [Player](OCTGN python api reference#player-class) | The player who will end up invoking the function
function | string | The name of the function that will be invoked
arguments| list | A list of arguments (of any object type) that will be passed to the remote player's function

Invokes a specific function on another players game. This is the recommended way to interact with objects(cards, piles, groups, tokens, etc) that are not controlled by the player calling this method.

**This is the only safe way to manipulate objects not controlled by the local player (`me`) and other methods will be deprecated in the future.**

Examples
```python
# This is a function that exists inside one of your definitions python files
def soundOff(id, play):
  notify("[{}]Sounds off {} (Started by {})".format(me,id,play));

# this is the call you would make to make all the players sounds turn off
def invokeSoundOff()
  i = 0
  for p in players
    remoteCall(p,"soundOff",[p._id,me])
    i = i+1

# if you run it
invokeSoundOff()

#You would get the results

# [player1]Sounds off 0 (Started by player1)
# [player2]Sounds off 1 (Started by player1)
```

**Note:** You have to pass the arguments list even if the remote function will have no argument. In this case simply pass an empty list object

e.g. ```remoteCall(p,"functionName",[])```

<a name="update" />
## update()

This function forces any networked based functionality executed by previous lines of code to complete.  This is a useful way of forcing OCTGN to 'catch up' for certain processes to finish.  Examples of issues which may be remedied by this function can be found here: [#412](https://github.com/kellyelton/OCTGN/issues/412) and [#110](https://github.com/kellyelton/OCTGN/issues/110).

----------

----------

<a name="playerClass" />
# PLAYER CLASS

All API functions in the Player Class require a Player object to be specified.

The Player class provides case-insensitive dynamic properties as shortcuts to game-defined piles and counters, assuming their names contains some invalid symbol such as a dot or a space)

```python
    me.deck  --> me.piles['Deck']
    me.score --> me.counters['Score']
```

``players`` is an unordered list of all Player objects on the table.  ``players[0]`` is ALWAYS the local player, and is shortcutted by using ``me`` as the player object. For example, ``players[0].name`` == ``me.name`` == ``"your name"``

When scripts are to refer to the local player, ALWAYS use ``me``.


 FUNCTION | DESCRIPTION | VERSION ADDED
----------|-------------|---------------
[color](#playercolor) | Returns the color associated with that player |
[counters](#playercounters) | Returns dictionary of all the player's counters and their values |
[getGlobalVariable()](#playergetglobalvariable) | Returns the value of a player's game-defined global variable |
[hand](#playerhand) | Returns the player's HAND object for further manipulations |
[hasInvertedTable()](#playerhasinvertedtable) | Returns TRUE if the player is on the "inverted" side B of a two-sided table. |
[isActivePlayer](#playerisactiveplayer) | Returns TRUE if it's currently the player's turn (Active Player) |
[name](#playername) | Returns the player's name. |
[piles](#playerpiles) | Returns dictionary of all the player's piles and their OBJECTS for manipulations |
[setActivePlayer()](#playersetactiveplayer) | Passes the Active Turn status to another player. |
[setGlobalVariable()](#playersetglobalvariable) | Sets the LOCAL PLAYER ONLY's game-defined global variable. |

<a name="playername" />
## player.name

Returns the **STRING** nickname of this player.

```python
name = player.name
print name
>>> "Bobby86"
```

<a name="playercolor" />
## player.color

Returns a **STRING** representing the color assigned to the player, in #HEX notation (i.e. #000000).

```python
color = player.color
print color
>>> "#3A3A00"
```

<a name="playerhand" />
## player.hand

Returns the player's [Hand object](#handClass), or None if this game doesn't use hands.

```python
hand = me.hand
print hand[0].name
>>> "Ace of Spades" #the name of the first card in my hand
```

<a name="playercounters" />
## player.counters

{INCOMPLETE}

Read-only; dictionnary containing this player's counters. Keys are names (case-insensitive); Values are Counter object, that have two properties: name and value (settable).
If the counter name is a valid Python identifier, its value can be accessed directly from the [Player object](#playerClass).

```python
      me.Score = 10
      me.counters['Score'].value += 1
```

<a name="playerpiles" />
## player.piles

{INCOMPLETE}

Read-only; Returns dictionary containing this player's piles. In this dictionary, the keys are pile names (case-insensitive); the values are the [Pile object](#pileClass) for that pile name.

NOTE: shared.piles will return a dictionary of all shared piles. 

<a name="playerhasinvertedtable" />
## player.hasInvertedTable()

Returns a boolean value determining if the player has an inverted table; *True* if the player is on the "inverted side" (side B) of a two-sided table.

Will always return *False* if the table is not two-sided.

```python
isInverted = me.hasInvertedTable()
print isInverted
>>> True
```

<a name="playerisactiveplayer" />
## player.isActivePlayer

Returns a boolean value determining if it is the player's turn (if it is currently that player's turn);

```python
isActive == me.isActivePlayer
print isActivePlayer
>>> False
```

<a name="playersetactiveplayer" />
## player.setActivePlayer()

Will pass the turn to the indicated player.  This function works identically to clicking the green "end turn" buttons on the player tabs, and will do nothing if you try to pass to the player who is already the active player.

NOTE: You cannot use this to take control of the turn, so me.setActivePlayer() will NEVER DO ANYTHING!

For 2 player games, you can use `players[1].setActivePlayer()` to pass the turn to your opponent (since they will always be the [1] index of the players list).

```python
players[1].setActivePlayer()
notify("{} passes the turn to {}.".format(me, players[1]))
>>> "Hugo passes the turn to Vincent."
```

<a name="playergetglobalvariable" />
## player.getGlobalVariable(name)

(see [this link](definition.xml#wiki-player) for more information on OCTGN's Player GlobalVariable system.)

| Argument | Type    |Description |
|----------|---------|------------|
| name | string | The name of a game-defined Global Variable |

Returns the **STRING** stored data that is defined in the Game Definition as **.

NOTE: *name* is stored in OCTGN as a **STRING**, and will probably need to be converted back into its original type.  You can do this with Python's `eval(var)` method.

```python
score = eval(me.getGlobalVariable("Score"))
print score
>>> 12
```

<a name="playersetglobalvariable" />
## player.setGlobalVariable(name, value)

(see [this link](definition.xml#wiki-player) for more information on OCTGN's Player GlobalVariable system.)

| Argument | Type    |Description |
|----------|---------|------------|
| name | string | The name of a game-defined Global Variable |
| value | string | The value to store into the Global Variable |

Stores the value into the Player's game-defined GlobalVariable.  **NOTE**: You can only set your own Player GlobalVariable, all other players are READ-ONLY.

**NOTE**: The variable MUST be converted to a **STRING** before it is stored via `player.setGlobalVariable()`.  You can do this with Python's `str(var)` method.

```python
score = me.counters['Score'].value
me.setGlobalVariable("Score", str(score))
```

----------

----------


<a name="groupClass" />
# GROUP CLASS

All API functions in the Group Class require a Group object to be specified.

In OCTGN, the Group class includes the [Table object](#tableClass), [Hand object](#handClass), and all [Pile object](#pileClass)s. Group classes behave like read-only collections. You can count the number of cards `len(table)`, access a specific card `me.Deck[3]`, take a slice `me.hand[2:5]` or iterate them `for c in table`.

Note that you can't modify this collection directly, use `card.moveTo()` and `card.moveToTable` instead.

The``<groupaction>` game action defined by the game definition will pass the Group object that the action is executed from as a parameter.  However, the bulk of these calls get filtered down to either the [Table class](#tableClass), [Hand class](#handClass), or [Pile class](#pileClass), depending on what group the function was executed from.

 FUNCTION | DESCRIPTION | VERSION ADDED
----------|-------------|---------------
[name](#groupname) | Returns the group's name. |
[player](#groupplayer) | Returns the owner of the group. |
[random()](#grouprandom) | Returns a random card inside the group. |
[controller](#groupcontroller) | Returns the active controller of the group. | 3.1.92 12/09/2013
[setController()](#groupsetcontroller) | Sets the active controller of the group. | 3.1.92 12/09/2013
[visibility](#groupvisibility) | Return the visibility of the group | 3.1.127 01/22/2014
[setVisibility](#groupsetvisibility) | Sets the visibiliy of the group | 3.1.127 01/22/2014

<a name="groupname" />
## group.name

Returns the name of the Group.

```python
name = group.name
print name
>>> "Hand"
```

<a name="groupplayer" />
## group.player

Returns the [Player object](#playerClass) of the owner of this Group.

```python
owner = group.player
notify("{} owns this card.".format(owner))
>>> "Marcel owns this card."
```

<a name="grouprandom" />
## group.random()

Returns a random [Card object](#cardClass) inside the group, or None if the group is empty.

```python
card = group.random()
card.moveToTable(0,0)
notify("{} randomly chose {}'s {} and moves it to the Table.".format(me, card.owner, card))
```

<a name="groupcontroller" />
## group.controller

Returns the player who is currently controlling (note: not owning) that group.

<a name="groupsetcontroller" />
## group.setController(player)


| Argument | Type    |Description |
|----------|---------|------------|
| player | [Player object](#playerClass) | The player to pass control to. |

Sets the active controller of the group to the specified [Player object](#playerClass).

<a name="groupvisibility" />
## group.visibility

Returns the visibility of the pile (none, all, custom, me, or undefined)

<a name="groupsetvisibility" />
## group.setVisibility(visibility)

| Argument | Type    |Description |
|----------|---------|------------|
| visibility | string | The value to set the visibility to. |

Sets the visibility of the group to the specified value.  Valid arguments are 'all', 'none', 'me', or 'undefined'.

----------

----------


<a name="tableClass" />
# TABLE CLASS

All API functions in the Table Class require the Table object to be specified.

The `<groupaction>` game action defined by the game definition will pass the Table object to the python function as a parameter, if the action is being executed from the Table.

 FUNCTION | DESCRIPTION | VERSION ADDED
----------|-------------|---------------
[create()](#tablecreate) | creates new cards onto the table, then Returns those cards |
[offset()](#tableoffset) | Returns a new tuple (x,y) slightly offset from the input (x,y) |
[isTwoSided()](#tableistwosided) | Returns TRUE if 'Use Two-Sided Table" was enabled. |
[isInverted()](#tableisinverted) | Returns TRUE if if the table is inverted at the given y coordinate |
[setBoardImage()](#tablesetboardimage) | Changes the Board Image of the table | 3.1.69 17/08/2013

<a name="tablecreate" />
## table.create(guid, x, y, quantity = 1, persist = False)

| Argument | Type    |Description |
|----------|---------|------------|
| guid | string | The GUID of the card you want to create |
| x | integer | The table's x-coordinate to place the card |
| y | integer | The table's y-coordinate to place the card |
| quantity | integer | **(OPTIONAL)** The number of cards to create (defaults to 1) |
| persist | boolean | **(OPTIONAL)** Specify if the card should still exist after being moved off the table (defaults to False) |

This method will create a card on the table with the specified arguments.  It also returns the [Card object](#cardClass) (or list of Card objects if quantity is greater than 1) of the newly-created card.

As long as persist is False, the cards will vanish from the game when they leave the table via any method.

NOTE: If the GUID doesn't exist in the database, or quantity is 0, this method will return `None` instead.

```python
cards = table.create('dfa86825-5f00-414f-89ae-d5745a4efc8e', 6, 100, quantity = 2, persist = False)
for card in cards:
    notify("{} created {}.".format(me, card))
>>> "Zack created Cakeman."
>>> "Zack created Cakeman."
```

Use this function in tandem with [askCard()](#askcard) if you want the player to choose a card to create from a filtered list of the card database.

```python
guid = askCard({'Type': 'Token', 'HP': '25'}, 'and')
card = table.create(guid, 0, 0, 1)
notify("{} created {}.".format(me, card))
>>> "Bruce created Cakezilla."
```

<a name="tableoffset" />
## table.offset(x, y)

| Argument | Type    |Description |
|----------|---------|------------|
| x | integer | The x-value of the card |
| y | integer | the y-coordinate of the card |

Returns a tuple (x,y) of **INTEGER** coordinates, slightly offset with respect to the input x and y parameters.

This method does a non-trivial work as it takes into account whether the table is two-sided, if y is in the inverted zone and the size of the cards.

{needs an example}

<a name="tableistwosided" />
## table.isTwoSided()

Returns True if the table was set to two-sided mode, else False.

```python
if table.isTwoSided():
    notify("The table is two-sided.")
else:
    notify("The table is NOT two-sided.")
>>> "The table is NOT two-sided.")
```

<a name="tableisinverted" />
## table.isInverted(y)

| Argument | Type    |Description |
|----------|---------|------------|
| y | integer | a y-coordinate on the table |

Checks to see if the local player's Table is inverted at the specified y-coordinate, and will return True if it is inverted, else False.

{practical example needed}

<a name="tablesetboardimage" />
## table.setBoardImage(path)

| Argument | Type    |Description |
|----------|---------|------------|
| path | string | the path of the board image to switch to |

Changes the board image for the local player. For example, if your game wants to flip the board image upside-down depending on certain game conditions.

When writing the string for the path, a few important rules to keep in mind:
- double backslashes \\ must be used as path separators.
- If the image is bundled in the game definition, a relative path can be used.  Do not start the string with backslashes (i.e. use `table.setBoardImage('Board\\board2.jpg')`  )
- Although not recommended, you can also target images on the drive (i.e. `table.setBoardImage('c:\\imagepath\\image.png')`  )

----------

----------


<a name="pileClass" />
# PILE CLASS

All API functions in the Pile Class require a Pile object to be specified.

All Piles are specifically defined in the Game Definition, and none are included with OCTGN.  The Hand and Table are not considered to be piles.

The `<groupaction>` game action defined by the game definition will pass the Pile object to the python function as a parameter, if the action is being executed from a Pile.

 FUNCTION | DESCRIPTION | VERSION ADDED
----------|-------------|---------------
[top()](#piletop) | Returns top [Card object](#cardClass) in the pile if count = None, else a list of top 'count' cards.  |
[bottom()](#pilebottom)  | Returns bottom [Card object](#cardClass) in the pile if count = None, else a list of bottom 'count' cards. |
[shuffle()](#pileshuffle) | Securely shuffles the pile. |

<a name="piletop" />
## pile.top(count = None)

| Argument | Type    |Description |
|----------|---------|------------|
| count | integer | **(OPTIONAL)** Specifies how many cards from the top of the pile to select (default None) |

Selects *count* number of cards from the top of the deck, and returns an **Array** of those cards as [Card object](#cardClass)s.

If count is None, or not specified, it will return the top [Card object](#cardClass) of the pile (not an Array).

Will return *None* if the pile is empty.

```python
card = me.Deck.top()
card.moveTo(me.hand)
```
```python
cards = me.Deck.top(10)
for c cards:
    c.moveTo(me.Discard)
```

<a name="pilebottom" />
## pile.bottom(count = None)

| Argument | Type    |Description |
|----------|---------|------------|
| count | integer | **(OPTIONAL)** Specifies how many cards from the bottom of the pile to select (default None) |

Functionally similar to [pile.top()](#piletop), except it starts from the bottom of the pile instead of the top.

<a name="pileshuffle" />
## pile.shuffle()

Securely shuffles the pile.

```python
me.Deck.shuffle()
>>> "Clark's Deck is shuffled"
```

----------

----------

<a name="cardClass" />
# CARD CLASS

All API functions in the Card Class require a Card object to be specified.

The ```<cardaction>``` game action defined by the game definition will pass the Card object to the python function as a parameter, if the action is being executed from a card (in any location).

 FUNCTION | DESCRIPTION | VERSION ADDED
----------|-------------|---------------
[name](#cardname) | Returns the chat-hoverable name of the card |
[model](#cardmodel) | Returns the GUID of the card |
[properties](#cardproperties) | Returns dictionary of all the card's custom properties and their values |
[owner](OCTGN #cardowner) | Returns the player OBJECT of the card's owner. |
[controller](#cardcontroller) | Returns the player OBJECT of the card's current controller. |
[group](#cardgroup) | Returns the group OBJECT that the card is currently located in. |
[markers](#cardmarkers) | Returns a DICTIONARY of all markers which can be edited via python. |
[isFaceUp](#cardisfaceup) | Returns or Sets the card's visibility status. |
[alternate](#cardalternate) | Returns the 'type' string (from the set XML) if a card is in an Alternate form, else "". |
[alternates()](#cardalternates) | Returns a LIST of all Alternate forms of the card, identified by their 'type' string. |
[alternateProperty()](#cardalternateproperty) | Returns a property value from an alternate form of the card. | 3.1.35 24/05/2013  
[switchTo()](#cardswitchto) | Switches a card to the specified Alternate form |
[highlight](#cardhighlight) | Returns or Sets the current highlight color as a string in #HEX color format. |
[orientaion](#cardorientaion) | Returns or Sets the current rotation of a card in 90 degree intervals. |
[position](#cardposition) | Returns the x,y coordinates of the card. |
[moveToTable()](#cardmovetotable) | Moves a card to specified coordinates on the table. |
[moveTo()](#cardmoveto) | Moves a card to a specified group. Top of piles if index = None. |
[moveToBottom()](#cardmovetobottom) | Moves a card to the BOTTOM of a specified PILE. |
[arrow()](#cardarrow) | Draws an arrow from the card to another card. active = False will remove the arrow. |
[setController()](#cardsetcontroller) | Changes a card's controller. |
[getIndex](#cardgetindex) | Returns the current index (z-value) of the card in a group. |
[setIndex()](#cardsetindex) | Sets the current index (z-value) of the card in a group. |
[select()](#cardselect) | Adds the card to the current selection. |
[target()](#cardtarget) | Targets the card, or removes target if active = False. |
[targetedBy](#cardtargetedby) | Returns the player OBJECT who is targeting the card. |
[width()](#cardwidth) | Returns the card's width as defined by the game. |
[height()](#cardheight) | Returns the card's height as defined by the game. |
[sendToBack()](#cardsendtoback) | Sends the card behind all other cards on the TABLE ONLY |
[sendToFront()](#cardsendtofront) | Sends the card in front of all other cards on the TABLE ONLY |
[peek()](#cardpeek) | Reveals the identity of the card to the local player while keeping it face-down. |
[delete()](#carddelete) | Eliminates the card from the game. | 3.1.91 10/9/2013

<a name="cardmodel" />
## card.model

Returns the **STRING** GUID of the [Card object](#cardClass).

```python
guid = card.model
print guid
>>> "dfa86825-5f00-414f-89ae-d5745a4efc8e"
```

<a name="cardname" />
## card.name

Returns the **STRING** name of the card.  This is useful when trying to store the card's name into other variable types, as the [Card object](#cardClass) only converts to the card's name in [notify()](#notify) and [whisper()](#whisper) methods.

```python
name = card.name
print name
>>> "Ace of Diamonds"
```

<a name="cardproperties" />
## card.properties

Returns the **dictionary** of all custom card properties as defined by the game definition. In the dictionary, each Key is a property name (case-insensitive); each Value is the value of the property.

The Card class provides dynamic properties to easily access game-defined properties, e.g. `card.Type` or `card.Cost`. Those dynamic properties are case-insensitive. If the property name can't be used that way (i.e. it contains some invalid symbol such as a dot or a space), use the long syntax instead: `card.properties["Collector Number"]`.

```python
properties = card.properties
print properties
>>> {'suit': 'Hearts', 'value': 'King', 'color': 'Red'}
print card.Suit
>>> 'Hearts'
```

<a name="cardowner" />
## card.owner

Returns the [Player object](#playerClass) of the player who owns that card.  The owner is the player who initially loaded the deck, or created it via [create()](#tablecreate).

```python
owner = card.owner
notify("{} is the owner of {}.".format(owner, card))
>>> "Bill is the owner of Ace of Spades."
```

<a name="cardcontroller" />
## card.controller

Returns the [Player object](#playerClass) of the player who currently controls that card.  The controller is the player who can manipulate the card.

```python
controller = card.controller
notify("{} is the controller of {}.".format(owner, card))
>>> Sam is the controller of Ace of Spades.
```

<a name="cardgroup" />
## card.group

Returns the specific group (as either a [Pile object](#pileClass), [Hand object](#handClass), or [Table object](#tableClass)) that the card is currently residing in.  Note that this will never actually return a [Group Object](#groupClass).

Note: since this is read-only, you cannot change a card's location with `card.group`.  Instead, use methods like [moveTo()](#cardmoveto) or [moveToTable()](#cardmovetotable).

```python
group = card.group
if group == table:
    notify("{} is currently in {}.".format(card, group))
>>> Three of Hearts is currently in table.
```

<a name="cardisfaceup" />
## card.isFaceUp

Returns a boolean value representing the visibility of the card.  Face-up cards are visible to all players, and will show the card's image.  Face-down cards are non-visible for all players, showing the card's default back image.

```python
if card.isFaceUp:
    notify("{} is currently face-up.".format(card))
>>> Jack of Hearts is currently face-up.
```

If the card is face-down, then Python cannot identify the card's name or properties.  The card name will not be hoverable.

```python
if not card.isFaceUp:
    notify("{} is currently face-down.".format(card))
>>> Card is currently face-down.
```

It can also be used to set the visibility status of the card.  Setting a card face-down will force Python to "Forget" the card's name and properties.

NOTE: If a card is being flipped face-down, make sure you place the notify text FIRST, otherwise you'll lose the name of the card.

```python
notify("{} flips {} face-down.".format(me, card))
>>> Jen flips King of Clubs face-down.
card.isFaceUp = False
notify("{} flips {} face-down.".format(me, card))
>>> Jen flips Card face-down.
```

<a name="cardalternate" />
## card.alternate

Returns the **STRING**  Alternate Form that the card is currently in, as defined by the alternate's Type in the set xml.  If the card is in its standard Form, it will return a blank string instead.

```python
alternate = card.alternate
print alternate
>>> ''
```

<a name="cardalternates" />
## card.alternates()

Returns a **List** of all Alternate Forms of a card, as defined by the alternate's Type in the set xml.  If the card has no alternate forms, the list will be empty.

```python
alternateList = card.alternates()
print alternateList
>>> ['altA', 'altB']
```

<a name="cardalternateproperty" />
## card.alternateProperty(alt, prop)

| Argument | Type    |Description |
|----------|---------|------------|
| alt | STRING | The Alternate Form to get the property from. |
| prop | STRING | The Custom Property to identify the value of. |

Returns the **STRING** or **INTEGER** value of a Custom Property belonging to a non-active Alternate Form of that card.

```python
altProperty = card.alternateProperty("A", "Suit")
print altProperty
>>> "Hearts"
```

<a name="cardswitchto" />
## card.switchTo(type = None)

| Argument | Type    |Description |
|----------|---------|------------|
| type | String | **(OPTIONAL)** The Alternate Form to switch to. |

This will swap the card to the specified Alternate Form 'type', if one exists.

if no *type* is specified, the card will revert to its standard form.

```python
card.switchTo('altA')
```

<a name="cardpeek" />
## card.peek()
*New in Octgn 3*

Reveals the identity of the card to the local player while keeping it face-down. This is identical to manually right-clicking and selecting "Peek at Card".  An eye icon will appear on the card, and hovering over it will show who is peeking at it.

Peeking at a card will allow Python to access the card's name and properties as though it were face-up.

Peeking at face-up cards does not have any effect.

```python
if not card.isFaceUp:
    card.peek()
    notify("{} is peeking at {}.".format(me, card))
>>> Diane is peeking at Queen of Spades.
```

<a name="cardsetcontroller" />
## card.setController(player)
*New in Octgn 3*

| Argument | Type    |Description |
|----------|---------|------------|
| player | [Player object](#playerClass) | the player to pass control to. |

This function mimics the functionality of the "pass control to --> player name" menu option when you right-click a card.  The [Player object](#playerClass) will become the controller of the card.

While it is possible to take control of other player's cards, this will soon be removed from the code base.

```python
card.setController(players[1])   #will pass control to your opponent (in two-player games)
notify("{} passes control of {} to {}.".format(me, card, players[1]))
>>> Joseph passes control of Six of Hearts to Jane.
```

<a name="cardorientation" />
## card.orientation

Returns the current orientation, or rotation, value of the card as an **INTEGER** value between 0 and 3.  OCTGN has four pre-defined *constants* that represent each of these values, which are interchangable:

0 = Rot0
1 = Rot90
2 = Rot180
3 = Rot270

```python
rotation = card.orientation
return rotation
>>> 2
```

It can also be used to SET the orientation of a card.

```python
card.orientation = Rot180
notify("{} rotated {} upside-down.".format(me, card))
>>> Jacques rotated Ace of Spades upside-down.
```

Note that those constants can be used in mathematical expressions as well: 

```python
rotation = card.orientation
card.orientation = rotation + Rot90
notify("{} rotated {} by 90 degrees.".format(me, card))
>>> Jacques rotated Ace of Spades by 90 degrees.
```

<a name="cardhighlight" />
## card.highlight

Returns the color of the highlight that is currently drawn around the card.  The returning value is a **STRING** in HEX (#rrggbb) color format, or None if no highlight is currently on the card.

```python
color = card.highlight
return color
>>> '#33AAFF'
```

It can also Set a highlight color for the card, replacing any previous color that may already be drawn.  To simplify this, it is recommended to declare constants in your script file to refer to specific colors.

```python
AttackColor = "#ff0000" # Red

card.highlight = AttackColor
```

<a name="cardposition" />
## card.position

Returns a **TUPLE** representing the x and y coordinates (as **INTEGER**s) of the card's position on the table.

```python
position = card.position
print position
>>> (3, 100)
```

```python
x, y = card.position
print x
>>> 3
print y
>>> 100
```

NOTE: This will NOT move the card around on the table, use [card.moveToTable()](#cardmovetotable) instead.

<a name="cardgetindex" />
## card.getIndex

Returns an **INTEGER** of the card's index in the group it is located in.  Index's are always **INTEGER** values of 0 or larger.

In a pile, an index of 0 is the top of the deck.

In a hand, an index of 0 is the left-most card.

On the table, an index of 0 is the card furthest to the back (behind all other cards).

```python
index = card.getIndex
print index
>> 3
```

<a name="cardsetindex" />
## card.setIndex(index)

| Argument | Type    |Description |
|----------|---------|------------|
| index | Integer | The index value to move the card to on the table. (Must be 0 or greater) |

Moves the card to the specified *index* value on the table.  In OCTGN, a card's index determines the order in which cards are 'stacked' on other cards.  A card with an index of 0 is on the 'bottom', behind all other cards.

```python
card.setIndex(5)
```

NOTE: This function only works for cards on the table.  For cards in hands or piles, use [card.moveTo()](#cardmoveto) instead.

<a name="cardsendtoback" />
## card.sendToBack()

Forces the card's index to 0, placing it behind all other cards.

NOTE: This function only works for cards on the table.  For cards in hands or piles, use [card.moveToBottom()](#cardmovetobottom) instead.

<a name="cardsendtofront" />
## card.sendToFront()

Forces the card's index large enough to be placed above all other cards. 

NOTE: This function only works for cards on the table.  For cards in hands or piles, use [card.moveTo()](#cardmoveto) instead.

<a name="cardmarkers" />
## card.markers

Returns the Marker Object for the card.  This Object is simply a dictionary of markers set on the card.  Keys in the dictionary are (name, GUID) tuples, where **STRING** *name* is the name assigned to that marker, and **STRING** *GUID* is the GUID of that marker.  Values in the dictionary are **INTEGER** *quantity* representing the number of that specific marker.

The GUID in the Key is used to retrieve a database image for that marker as defined in a [Set Definition XML](Set-Definition), if one exists.  If no match is found for that GUID, a pre-set marker image will be randomly assigned to that marker (see below).

```python
quantity = card.markers[("Damage Marker", "fabd2965-929e-4ee9-b69c-e278e3cd4098")]
print quantity
>>> 3
```

If two keys contains the same GUID but a different name (or vice versa), OCTGN will treat these as different marker objects.  As such, it is HIGHLY recommended to define constants for all of your markers in your python scripts.  This makes it easier to reference the marker you wish to use, and prevents unnecessary duplicates of dictionary keys.

```python
damageMarker = ("Damage Marker", "fabd2965-929e-4ee9-b69c-e278e3cd4098")
quantity = card.markers[damageMarker]
print quantity
>>> 3
```

**MODIFYING THE MARKER DICTIONARY**

You can add or remove markers from a card by modifying the Marker Object.  This can be done by performing mathematical operations on the dictionary's values.

```python
damageMarker = ("Damage Marker", "fabd2965-929e-4ee9-b69c-e278e3cd4098")
# Adding one marker
card.markers[damageMarker] += 1
# Removing one marker
card.markers[damageMarker] -= 1
# Setting the marker to a value
card.markers[damageMarker] = 4
print card.markers[damageMarker]
>>> 4
```

OCTGN includes its own internal set of marker images, which it will randomly assign to the Marker Object, in the event that the GUID is not found in the database.  You may also directly call these markers via the following GUIDs:

      "00000000-0000-0000-0000-000000000001" - white
      "00000000-0000-0000-0000-000000000002" - blue
      "00000000-0000-0000-0000-000000000003" - black
      "00000000-0000-0000-0000-000000000004" - red
      "00000000-0000-0000-0000-000000000005" - green
      "00000000-0000-0000-0000-000000000006" - orange
      "00000000-0000-0000-0000-000000000007" - brown
      "00000000-0000-0000-0000-000000000008" - yellow

<a name="cardmoveto" />
## card.moveTo(group, index = None)

| Argument | Type    |Description |
|----------|---------|------------|
| group | [Group Object](#groupClass) | The group where the card is moved to. |
| index | Integer | **(OPTIONAL)** A position within the group that the card is moved to. |

NOTE: Only [Pile object](#pileClass)s and [Hand object](#handClass)s can be the targets of the group argument.  For the [Table object](#tableClass), use [moveToTable()](#cardmovetotable) instead.

Moves the card to the specified group.  If an index is included, then the card will be placed at that index, starting at the top of piles or from the left side of the hand.
 
The default *index* is the top of piles, and to the right in hands.

```python
# will move the card 1 below the top card of a deck
card.moveTo(me.Deck, 1)
```

```python
# will move the card to your hand
card.moveTo(me.hand)
```

<a name="cardmovetobottom" />
## card.moveToBottom(pile)

| Argument | Type    |Description |
|----------|---------|------------|
| pile | [Pile object](#pileClass) | The pile where the card is moved to. |

Moves the card to the bottom of the specified pile.  Only [Pile Object](#pileclass)s can be used for this function, which does NOT include the [Hand object](#handClass) or the [Table object](#tableClass).

```python
card.moveToBottom(me.Deck)
```

<a name="cardmovetotable" />
## card.moveToTable(x, y, forceFaceDown = False)

| Argument | Type    |Description |
|----------|---------|------------|
| x | Integer | The x-position to move the card to. |
| y | Integer | The y-position to move the card to. |
| forceFaceDown | Boolean | **(OPTIONAL)** Forces the card to move to the table face-down. |

Moves the card to the table at the given (x, y) co-ordinates.  If the forceFaceDown argument is given as False, the card will be securely moved face-down, preventing players from knowing its identity.

```python
card.moveToTable(300, -150, True)
```

<a name="cardselect" />
## card.select()

Adds the card to current selection, or creates a selection if one is not already available.  Control+Click on a card will also add the card to a selection.

<a name="cardtarget" />
## card.target(active = True)

| Argument | Type    |Description |
|----------|---------|------------|
| active | Boolean | **(OPTIONAL)** Whether or not to draw a targeting reticle over the card (defaults to True) |

Creates a targeting reticule icon on the card. If *active* is False, it will remove all targets from the card instead.

<a name="cardtargetedby" />
## card.targetedBy

Read-only, returns the [Player object](#playerClass) of the player who is targeting this card, or None if the card is not targeted.

```python
if card.targetedBy == me:
   card.markers[ChargeMarker] += 1
```

<a name="cardarrow" />
## card.arrow(target, active = True)

| Argument | Type    |Description |
|----------|---------|------------|
| target | [Card object](#cardClass) | The card that the arrow will point to. |
| active | Boolean | **(OPTIONAL)** Whether or not to draw an arrow or remove an existing one (defaults to True) |

If `active` is set to *True*, this will draw an arrow from the card, pointing to the `target` [Card object](#cardClass).

If `active` is set to *False*, it will remove all targeting arrows originating from the card (currently, the `target` card is irrelevant in this case).  It will not remove arrows pointing to it.

<a name="cardwidth" />
## card.width()

Returns the **INTEGER** width value of the card as defined in the [game definition](#definition.xml#wiki-card).

<a name="cardheight" />
## card.height()

Returns the **INTEGER** height value of the card as defined in the [game definition](#definition.xml#wiki-card).

<a name="carddelete" />
## card.delete()

Eliminates the card from the game.  This works the same way as creating cards through [table.create()](#tablecreate) with `persist = False`.  

Note that this is irreversible, so cards that are deleted cannot be properly recovered.

# EXTRA STUFF

### Tip: how to select cards

Python has nice comprehensions to select objects. Here's a way to get all Land cards you control on the table:

```python
tableLands = [card for card in table
         if card.controller == me
         and re.search(r'\bLand\b', card.type)]
```

You can then iterate through them in a loop:

```python
for card in tableLands: card.moveTo(me.Discard)
```
or count them

```python
notify("You've got {} lands on the table".format(len(tableLands)))
```

you can even use on-the-fly list comprehensions to reveal cards from a player's hand without having to put them on the table first.

```python
notify("{} is holding the following actions in their hand: {}".format(me,[card.name for card in me.hand if card.Type == 'Action']))
```
etc...
### Re

re is the Regular Expression engine built-into Python, which is very useful to perform text matching. You need to import it first:

```python
    import re
```

The expression above: re.search(r'\bHero\b', card.type) checks whether the word 'Hero' (\b are marking word boundaries in a RegExp) appears into card.type.